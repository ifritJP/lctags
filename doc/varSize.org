# -*- coding:utf-8 -*-
#+AUTHOR: ifritJP
#+STARTUP: nofold

#+TITLE: C/C++ の変数サイズ確認 by lctags on emacs

C/C++ ではデータサイズを意識して開発することが必要です。

小さいサイズのデータはスタック上に作れば良いですが、
大きいサイズのデータをスタック上に作るとスタックオーバーフローしてしまいます。

まぁ、これは C/C++ に限らず Java や C# 等の他言語でも同じですが、
C/C++ を利用するようなプロジェクトでは他の言語のプロジェクトと比べて
顕著だと言えるでしょう。

プリミティブな型であればサイズを計算することは簡単です。
しかし、構造体となるとサイズ計算出来ないこともないですが、面倒です。

この面倒な作業を lctags を利用することで、簡単に実現できます。

lctags 全般の紹介は次を参照してください。

- C/C++ ソースコードタグシステム lctags の紹介
https://qiita.com/dwarfJP/items/982ef7ee3f3bfd435156


* 使い方

サイズを確認したい変数や型にカーソルを移動して、 C-c I するだけです。

これにより window が分割され、その window 内に幾つかの情報が表示されます。

その情報に typeSize があり、これがその変数、型のサイズとなります。

例えば、次のソースの ~VAL_t val~ の val にカーソルを移動し、C-c I すると

#+BEGIN_SRC c
typedef struct {
    int val1;
    int val2[10];
} VAL_t;

VAL_t val;
#+END_SRC

次のようなバッファが表示されます。

#+BEGIN_SRC txt
spelling: val
kindName: VarDecl
type: VAL_t
typeSize: 44(0x2C)
kind: 9(0x9)
#+END_SRC

これは、val のタイプが ~VAL_t~ で、サイズが 44 Bytes であることを示しています。


なお注意することは、
*これはあくまで clang でコンパイルした場合のサイズ* であるということです。

構造体のサイズは padding や alignment によって違ってきます。
そして、 padding や alignment はコンパイラ依存です。

ただコンパイラ依存といっても、参考値としては十分使用できるとレベルだと思います。

* 技術的な話
  
このサイズ情報は、libclang の CXType:getSizeOf() を表示しているだけです。

* どうでも良い話

実はこの情報を使って、関数のスタック使用量見積り機能も作ってたりするんですが、
サブ関数コール(静的、動的)を考えると見積りが難しいので公開していない状況だったりします。

GROSS で見積るのは難しいので、
NET のスタック使用量だけでも公開しようかなぁ、と思ってたり思ってなかったり。。
