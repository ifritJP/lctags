# -*- coding:utf-8 -*-
#+AUTHOR: ifritJP
#+STARTUP: nofold

#+TITLE: C 言語のプロジェクトにエンカウントしてしまったイマドキのエンジニアが気をつけるべきこと

* はじめに

クラウド全盛の時代に C 言語で開発する必然性は年々下っています。

十年一昔、いや二昔くらい前は、情報系学科の学習用言語といえば C 言語の一択でしたが、
2020 年のプログラミング必修科目に C 言語が採用されることは考え難いでしょう。

現在 C 言語が必要な分野は、
いわゆる IOT としてそこら中にばらまかれるデバイスなどの組込み製品や、
OS などのシステムくらいでしょうか。
なお、IOT デバイスなどの組込み製品でも、Linux ベースのものが年々増えています。
そういったデバイスでは C 言語である必要はありません。

そして、上記以外の分野では、 C 言語である必要は皆無と言って良いでしょう。
もちろん何らかの判断で C 言語が採用される可能性はありますが。。

そんな絶滅危惧言語として将来の暗い C 言語を触らずに済むならば
それに越したことはありません。
しかし、運悪く C 言語のプロジェクトにエンカウントしてしまうことも少なくないと思います。

特に日本では、
Linux ベースの製品であっても「組込み = C 言語」の図式が根強く残っているため、
組込み系製品の開発に携わる場合はまず間違いなく C 言語のソースをメンテなり
新規でスクラッチすることになります。

このドキュメントは、
運悪く C 言語のプロジェクトにエンカウントしてしまったイマドキのエンジニアが、
長老エンジニアの逆鱗に触れることなく仕事を全うするための作法を紹介するものです。

なお、ここでは C 言語の syntax 等は説明しません。
C ソースの読み書きは問題なく出来ることを前提とします。

また、ROM サイズが 100KB 前後で動いてしまうような規模のプロジェクトでは、
参考程度に読んでください。


* プロジェクトに参加する前にやっておくこと

** イマドキの言語のことは忘れよう

あなたはこれまでに Ruby や Python, JavaScript, C#, Java, Objective-c, Scala 等々、
さまざまな言語で数々のプロジェクトに参加し貢献してきたことでしょう。

ですが、まずは一旦そのことは忘れてください。

これからあなたが参加するのは C 言語のプロジェクトなのです。
残念ながら C 言語のプロジェクトでは、
イマドキの言語で身に付けたテクニックの多くは使えません。
これまであなたが使っていた便利な機能や関数、ライブラリは、
C 言語のプロジェクトでは使えないのです。

イマドキの言語と C 言語を比べるのはストレスが溜るだけなので、
きれいサッパリ忘れましょう。

** プロジェクトが採用する C 言語規格のバージョンを調べる

言語には規格のバージョンがあります。

例えば Java なら Java SE 8 でラムダ式が導入されたり、
C# では C# 7 でタプルが導入されています。

もちろん C 言語規格もバージョンがあります。

一般的に C 言語というと、
ANSI C あるいは C89 といわれるバージョンを指します。
このバージョンは 1989 年に C 言語として初めて規格化されたバージョンです。
その後 1999 に C99 が制定され、幾つかの機能が追加されています。

その後も新しい規格が制定されていますが、
言語仕様としては C99 でほぼ fix されていると言って良いと思います。

ただ、驚くことに C99 以降をサポートするコンパイラは少ないです。
規格制定から 20 年近く経過している現在もです。
先ほど『一般的に「C 言語」が C89 を指す』と書いたのも、このためです。

C 言語のコンパイラで C99 以降をサポートするのは、
gcc か clang、 armcc、あとは開発ツールを販売している一部の 3rd パーティ製
コンパイラくらいでしょう。
gcc で対応していれば十分だと考える方もいるかとも思いますが、
組込み製品では gcc 以外のコンパイラを利用するケースも多いでしょう。

では、プロジェクトで採用する言語のバージョンをどのように決めるか、
というと、そのプロジェクトが新規かそうでないかで大きく分かれます。

まず、新規プロジェクトでない場合は、
プロジェクトの過去資産との互換性を重視して決定するのが一般的でしょう。
つまりは、過去のプロジェクトと同じバージョンを使うことになります。

一方、新規プロジェクトの場合は、
採用する CPU に対応したコンパイラの中から選択することになります。
ただ、ほとんどの場合はコンパイラを選択するというよりは、
採用するプラットフォームで選択され、
コンパイラはそのプラットフォームに付属するものを利用する形になるでしょう。
そして、採用されたコンパイラが C89 対応か C99 以降も対応しているのかが決まります。

しかし、コンパイラ自体が C99 以降を対応していたとしても、
プロジェクトでは C89 までしか使えない、ということも良くあります。

何故かというと、何度も言うようですが、
C99 以降をサポートするコンパイラが限られるため、
移植性を考えると C89 に限定した方が良い、という結論に成りがちだからです。

なお、自動車業界でお馴染の MISRA-C では、
MISRA-C:2012 から C99 対応になっています。
MISRA-C:2012 というは、その名の通り 2012 年に策定されたものです。
つまり、少なくとも MISRA-C を採用していたプロジェクトでは、 
2012 年までは C89 しか使用できなかったことを示しています。

では、2018 年現在では「MISRA-C を採用している = C99 が利用できる」なのかと言うと、
そうとは限りません。
あくまで MISRA-C:2012 で使えるようになったというだけで、
MISRA-C:2012 より前の MISRA-C を採用しているプロジェクトであれば、
C99 は使えないままです。

長々と前置きを書いてしまいましたが、結局何が言いたかったかというと、
もしもプロジェクトで採用されているバージョンが C89 だった場合は覚悟が必要だ、
ということです。

C 言語というだけでモチベーションがだだ下りですが、
C99 が使えないなんて言われた日には、
もう無我の境地で悟りを開かないとやってられないレベルです。

そのプロジェクトへの参加を全力で回避するか、
回避が出来ないなら要件を最小限に絞り込んで、
なるべくコード量を減らす方法を考えましょう。

* プロジェクトで一番「出来る人」のソースを読む

プロジェクトに参加することになってしまった場合、
まずはそのプロジェクトで一番「出来る人」のソースを見てみましょう。

** プロジェクトの水準を知る

これは C 言語に限った話ではなないですが、
一番「出来る人」のソースを見ることで、そのプロジェクトの水準が分かります。

優秀なエンジニアばかり集めているどこぞの IT 企業でもない限り、
どのプロジェクトでも出来ない人の水準はかなり低いです。
一方で、出来る人の水準はプロジェクトによって、かなりばらけます。
その出来る人のソースを見ることで、そのプロジェクトの最大瞬間風速的なものが分かります。

なお、見ると言っても処理内容を見るのではなく、どの様にソースを書いているか、を見ます。

例えば次の事を見ると最低限のことが分かります。

- 1 行の文字数が無駄に長くなっていないか？
- 変数、関数等のシンボル名が意味の分かり易いものになっているか？
- グローバル変数が使われていないか？
- 1 つの関数の行数が長過ぎないか？
- static や const が効果的に使われているか？
- if や for 等のブロックのネストが深くないか？  

プロジェクトで一番「出来る人」のソースで、
上記の内、一つでもツッコミを入れたい箇所を見つけたら、
間違いなくそのプロジェクトは後で大変なことになります。
どうにかして、プロジェクトを抜けるための行動をしましょう。

それが出来ないなら、プロジェクトメンバー全体の教育が必要です。

** 便利機能を知る

「出来る人」のソースを見ることで、
プロジェクトの水準を知る以外に、もう一つ分かることがあります。

それは、そのプロジェクトで使える便利機能です。

C の標準関数は最低限のものしかありません。
その最低限のものだけではプロジェクトは完成しないので、
何らかしらの機能を追加導入しています。

「出来る人」は、そういった追加導入している機能の内、
本当に使えるものを取捨選択して使いこなしています。

「出来る人」のソースを見て、
使える機能を把握しておくことで効率良く開発することが出来ますし、
リファレンスを読むよりもよほど時間の短縮が可能です。

* 設計

どんな言語で開発するにしても設計は重要ですが、
C 言語で組込み製品を開発する場合は、
イマドキの言語ではあまり気にしないことも考慮して設計する必要があります。

** HEAP と固定領域とスタック

イマドキの言語では、HEAP とスタックを意識することはほとんど無いと思いますが、
C 言語では必須です。

C 言語ではデータは基本的にスタックに詰まれます。
搭載するメモリリソースの量にもよりますが、
1 関数のスタック使用量が 100Byte 以上になったら、
スタック量追加や、固定領域の利用、 HEAP の利用を検討する必要があります。

その際、対応方法ごとに次のリスクを考えなければなりません。

- スタック量追加
  - RAM サイズ増加のリスク
- 固定領域
  - RAM サイズ増加のリスク
  - 固定領域の排他制御
- HEAP 
  - 開放忘れや開放済みの領域へのアクセスのリスク
  - HEAP サイズの見積り

一番簡単な対処方法はスタックを増やすことですが、
この場合どのスレッドのスタックを増やせば良いのかを確認 & 監視する必要があります。

次に固定領域にする場合は、
排他制御の抜け漏れが起き易いので注意が必要です。
また固定領域の管理方法次第では、後述する HEAP と同じリスクが発生します。

最後の HEAP に関しては、
組込みではそもそも使用が制限されていることが多いと思います。

制限される理由としては、次のものが挙げられます。

- alloc/free のオーバーヘッドの大きさ
- メモリリークに関連する様々なリスク
- HEAP サイズの見積りの難しさ

これらのリスクは、スタック追加や固定領域のリスクに比べると、大きなものになります。
こういったリスクがあるため、
どういう時に HEAP を使って良いのかプロジェクトの方針を事前に確認しておきましょう。

GC を搭載しているイマドキの言語であれば、
HEAP を使うことにそこまで慎重になる必要はないのですが、
C 言語の場合は慎重な対応が必要です。

** カプセル化

オブジェクト指向開発対応言語でない C 言語で、カプセル化なんてどういうこと？
と思う方もいると思います。
ここでは C 言語でのカプセル化の考え方について説明します。

まずは C 言語規格のおさらいです。

C 言語にはグローバルとローカルがあります。
というか、それしかありません。

よって、カプセル化で隠蔽する処理はローカルにし、公開する処理はグローバルにします。
当たり前なことですが、基本はこれで制御することになります。

*** ヘッダファイルに書く情報

カプセル化の考え方として、「ローカルのものはヘッダファイルには書かない」があります。

C 言語の参考書によっては、
関数のプロトタイプ宣言や struct、enum、#define 等はヘッダファイルに書く、
と説明をしているモノもあるようです。
しかし、ヘッダファイルは誰かがインクルードする可能性があります。
そして、誰かがインクルードするということは、インクルードした人も使えるということになります。

もちろん関数を static 宣言していれば、
インクルードしても同じモノにアクセスすることは出来ません。
しかし、構造体の型や #define 等は参照できてしまい、カプセル化としてイマイチです。

よって、ヘッダファイルには公開情報のみを記載すべきです。

*** モジュール分割

モジュールの規模が大きくなると、ファイルを分割する必要があります。
その場合は、モジュール内限定で公開するヘッダと、モジュール外に公開するヘッダとを
分けて管理することになります。
ただし、モジュール内限定で公開するヘッダとして作成したとしても、
そのヘッダをモジュール外からインクルードすることは出来てしまいます。
モジュール外からインクルードしないというのはあくまでも紳士協定でしかなく、
C 言語として禁止出来るものではありません。

ですから、
モジュール内限定で公開するヘッダに書く情報も必要最低限にするべきです。

   
*** 構造体型情報の公開

オブジェクト指向では、クラスのメンバにアクセスするには、
直接メンバにアクセスするのではなく、
メンバにアクセスするためのメソッド(アクセッサ)を介してアクセスします。

一方 C 言語の場合、メンバを含んだ構造体の定義を公開してしまうと、
そのメンバに対するアクセスを制限することは出来ません。

例えば、次の構造体の定義をヘッダファイルに含む場合、
そのヘッダファイルをインクルードしたところからは
制限なく TEST 構造体の value メンバにアクセス出来てしまいます。

#+BEGIN_SRC c
struct TEST {
  int value;
};
#+END_SRC

これを制限するには、次のようにメンバを含まない構造体定義をヘッダファイルにします。

==ー#+BEGIN_SRC c
struct TEST;
#+END_SRC

そして、実際に TEST 構造体を操作するモジュールのソース内で改めてメンバを含む定義をします。

#+BEGIN_SRC c
struct TEST {
  int value;
};
#+END_SRC

こうすることで、外部モジュールからは TEST 構造体のメンバにアクセスが出来なくなります。

ただしこの場合、外部モジュールでは TEST 構造体のポインタ型変数は作れますが、
TEST 構造体の変数を作れなくなります。
つまり、TEST構造体のインスタンスは固定領域かHEAPにつくることになり、
注意が必要です。

#+BEGIN_SRC c
struct TEST test; // これは出来ない
struct TEST * pTest; // これは出来る
#+END_SRC

メンバの隠蔽と、
インスタンスのメモリ制御簡易化どちらを優先すべきかは一概には言えません。

*** アクセッサ(get 系/set 系) の公開

これは C 言語に限った話ではなく一般的な話ですが、
アクセッサの公開は十分な注意が必要です。

まず大前提として、アクセッサは必要最低限のものだけを公開します。
そして、get 系はもちろんですが、set 系は get 系以上に公開する際に注意が必要です。

また、get 系でもポインタを取得するものであれば、
そのポインタに const がないと set 系を公開していることと同じことなので、
注意が必要です。

まとめると、アクセッサを公開する場合は、次の順に検討が必要です。

- ポインタ型でない get
- const ポインタの get
- set, const でないポインタの get

*** グローバル変数

グローバル変数はカプセル化の考え方から逸脱するため、
原則的には使うべきではありません。

しかし、RTOS の kernel 情報のように非常に高速性が求められるような場合で、
アクセッサを通すと規定のパフォーマンスを得られない時は、
グローバル変数に直接アクセスすることも検討が必要です。


** デザインパターンなどの設計手法

デザインパターンというと、オブジェクト指向が前提のように思われるかもしれませんが、
C 言語でも実現可能です。

もちろん実現しやすさでいえば、
オブジェクト指向開発対応言語と比べるとハードルは上がりますが、
それでもデザインパターンの考え方自体は C 言語でも重要です。

また、デザインパターンだけでなく関数型プログラミングなどの
設計手法を取り入れることが必要です。


最初に「イマドキの言語のことは忘れろ」と書きました。
それは「無い物ねだり」してもどうにもならないからです。
しかし、イマドキの設計手法に関しては、C 言語でも実現可能です。
もちろん C 言語で実現できないものや、
実現するには非常にコストがかかるモノもありますが、
それでも検討する価値はあります。

化石的な C 言語を使用しているとはいえ、
設計手法まで昔のままで良いという訳ではありません。

* 実装

** コーディング規約を確認する

まともなプロジェクトであれば、
なんらかのコーディング規約を採用しているはずです。
まずはコーディング規約を確認しておきましょう。

ただ、コーディング規約がメンテされていないこともあります。
念のため、識者にコーディング規約の内容を確認しておきましょう。

** コーディング規約がない場合

コーディング規約がない場合、コーディング規約を一から作成するのでも良いですが、
公開されているコーディング規約をもとに作成するのが良いでしょう。

その際、元のコーディング規約そのままコピーするのではなく、
効果のあるものを選択し、足りないものを追加することで、
プロジェクトに最適化したコーディング規約を作るべきです。

また、コーディング規約はプロジェクト全体で守って意味のあるものなので、
コーディング規約の作成はメンバー全員の合意をもとに行なうべきです。

** C 言語規格で未定義の処理を避ける

案外知られていませんが、
C 言語規格では処理系(コンパイラ)依存のものが多いです。
代表的なもので言うと、 int や long のビット長は処理系依存です。

処理系依存のコードを書いてしまうと移植性に問題が出るため、避けるべきです。

何が処理系依存なのかは規格書を読むのが確実ですが、
規格書は読み難いところが多いので C リファレンスマニュアル等の参考書を
入手するのが良いでしょう。

良く間違われる処理系依存のものを挙げると、次のものがあります。

- 整数型のビット長
- ポインタ型のビット長
- struct のビットフィールド  
- struct の padding, アライメント
- NULL の値

当然バイトオーダーも処理系によって異なります。

ビットフィールドにおいては、
ビットストリームのデータを扱う際に struct のビットフィールドの利用が
紹介されていることが多いですが、
ビットフィールドで定義したデータがメモリ上にどのように格納されるかは処理系依存であり、
C 言語規格で保証されているものではありません。
よって、本来はビットストリームのデータを扱う際にビットフィールドを
利用すべきではありません。

** C 言語規格を確認しなくても良いコードを書く

コーディング規約では些細なことは定義していないことが良くあります。
むしろ、些細なことまでコーディング規約で定義するべきではありません。

では、コーディング規約の定義外のことならばどのようなコードでも書いて良いかどいうと、
そうではありません。

前述したように、C 言語規格で未定義の処理を避けるのは当然ですが、
たとえ C 言語規格に準拠していたとしても、
規格書を引っ張り出さないと正否が確認できないような処理は避けるべきです。

例えば複合式の演算子優先順序などは、
規格的に問題がないとしても適度に () で括って
確実に目的の処理が行なわれるようにするべきです。
ただし、四則演算などの一般常識と言えるものまで () で括ってしまうと
逆に読み辛くなるので、バランスをとりましょう。


** 最適化を意識してコードを書かない

プログラムは、コードによって実行速度に大きな違いが出ます。

しかし、製品の実行速度に影響するのは全体コードの 1 割程度です。
残りの 9 割は製品の実行速度にほとんど影響することの無いコードになります。

製品の実行速度に影響する 1 割のコードは実行速度の最適化を意識する必要がありますが、
そうでないコードは最適化を意識すべきではありません。
もちろん、敢えて遅くなるように書くようなことをするべきではないですが、
優先度としてはメンテナンス性を第一に考えるべきです。

ちなみにここで言う最適化とは、コンパイラが行なうような小手先の最適化です。
たとえば、for などのループを使用せずに直に繰り返し処理を書くことや、
関数呼び出しを使用せずに inline 展開を自前でやったり。
そういう小手先の最適化はコンパイラに任せ、
エンジニアはアルゴリズムレベルの最適化に注力するべきです。


なお、実行速度に影響する 1 割のコードについてもメンテナンス性重視は同じです。
実装する際は、まずメンテナンス性を第一に考えてコーディングし、
必要に応じて実行速度の最適化を意識したコーディングでチューニングすべきです。

ただし、製品の目標速度に大きな乖離がある場合、
設計からやりなおさなければならないこともあります。
そのようなことがないように、
ネックになる処理が分っているのであればその部分を先にプロトタイプで開発し、
どのように設計すれば目標を達成できるかを検討しておく必要があります。

実行速度に影響するのは全体コードの 1 割程度になりますが、
ROM/RAM サイズへの影響は、コード全体になることが多いです。
ROM/RAM サイズは常に意識しましょう。
とはいえ、コード上のステップ数を多少減らしても ROM/RAM サイズはほとんど変わりません。
また、コード上のステップ数を減らすことはメンテナンス性を下げることに繋るため、
オススメしません。
ROM/RAM サイズの削減は、アルゴリズムの見直しなど、より大きな目線での対応が必要です。

** ログを残す

イマドキの言語では、ランタイムエラーが発生した場合、
どこでどういうエラーが発生したかをトレースできる仕組みが用意されています。
一方 C 言語でランタイムのエラーが発生した場合、そのような仕組みはありません。

gdb のようなデバッガで動作させた場合はトレース可能な場合もありますが、
そのようなデバッガを使えるとは限りません。
また、デバッガを使うと発生しなくなるような不具合もあります。

このような時のために、ログは必須です。

ログは、処理がどこまでいったかをトレースできるようにするログと、
異常検知時のログを出力します。
トレース用のログは多過ぎるとノイズとなり、
少な過ぎると解析できなくなってしまうので、バランスが重要です。


** if/ifdef は最小限に

if/ifdef のプリプロセッサは C 言語で良く使う機能の一つですが、
これを多用すると可読性が落ちます。
また、イマドキの言語では if/ifdef に該当する機能を持っていないことからも、
この機能はプログラミング言語には必須でないことが伺えます。

あると便利なので、つい使ってしまいますが、
使わないでも開発できるような設計を検討しましょう。

** REPL の対応

モジュールで利用しているパラメータは REPL で変更可能なように対応しましょう。
それによって、開発効率が上がります。
特に wait 処理の時間係数や、計算に利用する係数などを REPL で変更可能にすることで、
いちいちコンパイルする必要がなくなり時間が短縮できるため、テストが楽に行なえます。

組込みでは、REPL 用に使えるインタフェースの空きがない、というようなこともあると思います。
そのような場合、
例えば使用頻度の高くないインタフェースを REPL のインタフェースとして共有し、
DIPSW でインタフェースを切り替えるようにする。等で実現できると思います。

その辺りはハードウェア屋を交えて検討すべきです。

* テスト

** 効率
  
C 言語は、イマドキの言語と比べて非常に生産性の低い言語です。
その生産性の低さは、テストコードの書き難さにも繋がります。
そのため、ただでさえ生産性が低いのにテストも書くとなると非常にテンションが下ります。

ただ、 C 言語は静的型付け言語なので、
型関連のエラーの多くはコンパイル時にチェックできます。
つまり、スクリプト系の動的型付け言語に比べれば、
ランタイムエラーの多くを防止出来ているといえます。
また、文法的にもイマドキの言語と比べて単純なので、
市販の静的コード解析ツールによって、ある程度の不具合を検出することもできます。
そういう意味では、イマドキの言語よりも少ないテストで済む、と言えるかもしれません。

とはいえ、テストが書き難いのは間違いありませんが。

** テストの書き方

テストを書く際は、次のことを原則としてテストします。

- テストは公開 IF を対象にする。
  - 網羅率を上げるには、内部 IF を直接叩いた方が上げやすいですが、
    内部 IF は将来変更になる可能性が高いので、テストでその内部 IF を利用してしまうと、
    内部 IF 変更の度にテスト作り直しになってしまいます。
  - また、内部 IF を直接叩くと公開 IF が叩くフローとは異なるフローになり、
    それによって不具合が発見できなくなる可能性があります。
- テスト用のコードを製品コードに含めない。
  - テスト用のコードを製品に含めてしまうと ROM/RAM の増加になるし、
    メンテナンス性も悪くなります。

