# -*- coding:utf-8 -*-
#+AUTHOR: ifritJP
#+STARTUP: nofold

#+TITLE: C 言語で組込み製品を開発する際に気をつけるべきこと

* はじめに

クラウド全盛の時代に C 言語で開発する必然性は年々下っています。

十年一昔、いや二昔くらい前は、情報系学科の学習用言語といえば C 言語の一択でしたが、
2020 年のプログラミング必修科目に C 言語が採用されることは考え難いでしょう。

現在 C 言語が必要な分野は、いわゆる IOT としてそこら中にばらまかれるデバイスや、
組込み製品、OS などのシステムくらいでしょうか。
なお、IOT デバイスや組込み製品でも、Linux ベースのものが増えて来ています。
そういったデバイスでは C 言語である必要はありません。

そして、上記以外の分野では、 C 言語である必要はほぼ無いと言って良いでしょう。
もちろん何らかの判断で C 言語が採用される可能性はありますが。。

そんな絶滅危惧言語として将来の暗い C 言語を触らずに済むならば
それに越したことはありません。
しかし、運悪く C 言語のプロジェクトにエンカウントしてしまうことも少なくないと思います。

特に日本では、
Linux ベースの製品であっても「組込み = C 言語」の図式が根強く残っているため、
組込み系製品の開発に携わる場合はまず間違いなく C 言語のソースをメンテなり
新規でスクラッチすることになります。

このドキュメントは、
運悪く C 言語のプロジェクトにエンカウントしてしまったイマドキのエンジニアが、
長老エンジニアの逆鱗に触れることなく仕事を全うするための作法を紹介するものです。

なお、ここでは C 言語の syntax 等は説明しません。
C ソースの読み書きは問題なく出来ることを前提とします。

また、ROM サイズが 100KB 前後で動いてしまうような規模の
プロジェクトも除外します。

* プロジェクトに参加する前にやっておくこと

** イマドキの言語のことは忘れよう

あなたはこれまでに Ruby や Python, JavaScript, C#, Java, Objective-c, Scala 等々、
さまざまな言語で数々のプロジェクトに参加し貢献してきたことでしょう。

ですが、まずは一旦そのことは忘れてください。

これからあなたが参加するのは C 言語のプロジェクトなのです。
残念ながら C 言語のプロジェクトでは、
イマドキの言語で身に付けたテクニックの多くは使えません。
これまであなたが使っていた便利な機能や関数、ライブラリは、
C 言語のプロジェクトでは使えないのです。

イマドキの言語と C 言語を比べるのはストレスが溜るだけなので、
きれいサッパリ忘れましょう。

** プロジェクトが採用する C 言語規格のバージョンを調べる

言語には規格のバージョンがあります。

例えば Java なら Java SE 8 でラムダ式が導入されたり、
C# では C# 7 でタプルが導入されています。

もちろん C 言語規格もバージョンがあります。

一般的に C 言語というと、
ANSI C あるいは C89 といわれるバージョンを指します。
このバージョンは 1989 年に C 言語として初めて規格化されたバージョンです。
その後 1999 に C99 が制定され、幾つかの機能が追加されています。

その後も新しい規格が制定されていますが、
言語仕様としては C99 でほぼ fix されていると言って良いと思います。

ただ、驚くことに C99 以降をサポートするコンパイラは非常に少ないです。
規格制定から 20 年近く経過している現在もです。
先ほど『一般的に「C 言語」が C89 を指す』と書いたのも、このためです。

C 言語のコンパイラで C99 以降をサポートするのは、
gcc か clang、 armcc、あとは開発ツールを販売している一部の 3rd パーティ製
コンパイラくらいでしょう。

では、プロジェクトで採用する言語のバージョンをどのように決めるか、
というと、そのプロジェクトが新規かそうでないかで大きく分かれます。

まず、新規プロジェクトでない場合は、
プロジェクトの過去資産との互換性を重視して決定するのが一般的でしょう。
つまりは、過去のプロジェクトと同じバージョンを使うことになります。

一方、新規プロジェクトの場合は、
採用する CPU に対応したコンパイラの中から選択することになります。
ただ、ほとんどの場合はコンパイラを選択するというよりは
採用するプラットフォームで選択され、
コンパイラはそのプラットフォームに付属するものを利用する形になるでしょう。
そして、採用されたコンパイラが C89 対応か C99 以降も対応しているのかが決まります。

しかし、コンパイラ自体が C99 以降を対応していたとしても、
プロジェクトでは C89 までしか使えない、ということも良くあります。

何故かというと、何度も言うようですが、
C99 以降をサポートするコンパイラは稀なため、
移植性を考えると C89 に限定した方が良い、という結論に成りがちだからです。

なお、自動車業界でお馴染の MISRA-C では、
MISRA-C:2012 から C99 対応になっています。
MISRA-C:2012 というは、その名の通り 2012 年に策定されたものです。
つまり、少なくとも MISRA-C を採用していたプロジェクトでは、 
2012 年までは C89 しか使用できなかったことを示しています。

では、2018 年現在では「MISRA-C を採用している = C99 が利用できる」なのかと言うと、
そうとは限りません。
あくまで MISRA-C:2012 で使えるようになったというだけで、
MISRA-C:2012 より前の MISRA-C を採用しているプロジェクトであれば、
C99 は使えないままです。


長々と前置きを書いてしまいましたが、結局何が言いたかったかというと、
もしもプロジェクトで採用されているバージョンが C89 だった場合は覚悟が必要だ、
ということです。

C 言語というだけでモチベーションがだだ下りですが、
C99 が使えないなんて言われた日には、
もう無我の境地で悟りを開かないとやってられないレベルです。

そのプロジェクトへの参加を全力で回避するか、
回避が出来ないなら要件を最小限に絞り込んで、
なるべくコード量を減らす方法を考えましょう。

* プロジェクトで一番「出来る人」のソースを読む

プロジェクトに参加することになってしまった場合、
まずはそのプロジェクトで一番「出来る人」のソースを見てみましょう。

** プロジェクトの水準を知る

これは C 言語に限った話ではなないですが、
一番「出来る人」のソースを見ることで、そのプロジェクトの水準が分かります。

優秀なエンジニアばかり集めているどこぞの IT 企業でもない限り、
どのプロジェクトでも出来ない人の水準はかなり低いです。
一方で、出来る人の水準はプロジェクトによって、かなりばらけます。
その出来る人のソースを見ることで、そのプロジェクトの最大瞬間風速的なものが分かります。

なお、見ると言っても処理内容を見るのではなく、どの様にソースを書いているか、を見ます。

例えば次の事を見ると最低限のことが分かります。

- 1 行の文字数が無駄に長くなっていないか？
- 変数、関数等のシンボル名が意味の分かり易いものになっているか？
- グローバル変数が使われていないか？
- 1 つの関数の行数が長過ぎないか？
- static や const が効果的に使われているか？
- if や for 等のブロックのネストが深くないか？  

プロジェクトで一番「出来る人」のソースで、
上記の内、一つでもツッコミを入れたい箇所を見つけたら、
間違いなくそのプロジェクトは後で大変なことになります。
どうにかして、プロジェクトを抜けるための行動をしましょう。

それが出来ないなら、プロジェクトメンバー全体の教育が必要です。

** 便利機能を知る

「出来る人」のソースを見ることで、
プロジェクトの水準を知る以外に、もう一つ分かることがあります。

それは、そのプロジェクトで使える便利機能です。

C の標準関数は最低限のものしかありません。
その最低限のものだけではプロジェクトは完成しないので、
何らかしらの機能を追加導入しています。

「出来る人」は、そういった追加導入している機能の内、
本当に使えるものを取捨選択して使いこなしています。

「出来る人」のソースを見て、
使える機能を把握しておくことで効率良く開発することが出来ますし、
リファレンスを読むよりもよほど時間の短縮が可能です。

* 設計

どんな言語で開発するにしても設計は重要ですが、
C 言語で組込み製品を開発する場合は、
イマドキの言語ではあまり気にしないことも考慮して設計する必要があります。

** HEAP と固定領域とスタック

イマドキの言語では、HEAP とスタックを意識することはほとんど無いと思いますが、
C 言語では必須です。

C 言語ではデータは基本的にスタックに詰まれます。
搭載するメモリリソースの量にもよりますが、
1 関数のスタック使用量が 100Byte 以上になったら注意になり、
スタック量追加や、固定領域の利用、 HEAP の利用を検討する必要があります。

その際、次のリスクを考えなければなりません。

- スタック量追加
  - RAM サイズ増加のリスク
- 固定領域
  - RAM サイズ増加のリスク
  - 固定領域の排他制御
- HEAP 
  - 開放忘れや開放済みの領域へのアクセスのリスク
  - HEAP サイズの見積り

一番簡単な対処方法はスタックを増やすことですが、
この場合どのスレッドのスタックを増やせば良いのかを確認 & 監視する必要があります。

次に固定領域にする場合は、
排他制御の抜け漏れが起き易いので注意が必要です。

最後の HEAP に関しては、
組込みではそもそも使用が制限されていることが多いと思います。

制限される理由としては、次のものが挙げられます。

- alloc/free のオーバーヘッド大きさ
- メモリリークに関連する様々なリスク
- HEAP サイズの見積りの難しさ

これらのリスクは、スタック追加や固定領域のリスクに比べると、大きなものになります。
こういったリスクがあるため、
どういう時に HEAP を使って良いのかプロジェクトの方針を事前に確認しておきましょう。

GC を搭載しているイマドキの言語であれば、
HEAP を使うことにそこまで慎重になる必要はないのですが、
C 言語の場合は慎重な対応が必要です。

** カプセル化

オブジェクト指向開発対応言語でない C 言語でカプセル化なんてどういうこと？
と思う方もいると思います。
ここでは C 言語でのカプセル化の考え方について説明します。

まずは C 言語規格のおさらいです。

C 言語にはグローバルとローカルがあります。
というか、それしかありません。

よって、カプセル化で隠蔽する処理はローカルにし、公開する処理はグローバルにします。
当たり前なことですが、基本はこれで制御することになります。

*** ヘッダファイルに書く情報

カプセル化の考え方として、「ローカルのものはヘッダファイルには書かない」があります。

C 言語の参考書によっては、
関数のプロトタイプ宣言や struct、enum、#define 等はヘッダファイルに書く、
という説明をしているモノもあるようです。
しかし、ヘッダファイルは誰かがインクルードする可能性があります。
そして、誰かがインクルードするということは、その人も使えるということになります。

もちろん static 宣言していれば、
インクルードしても同じモノにアクセスすることは出来ません。
しかし、構造体の型や #define 等は参照できてしまい、カプセル化としてイマイチです。

よって、ヘッダファイルには公開情報のみを記載すべきです。

*** モジュール分割

モジュールの規模が大きくなると、ファイルを分割する必要があります。
その場合は、モジュール内限定で公開するヘッダと、モジュール外に公開するヘッダとを
分けて管理することになります。
ただし、モジュール内限定で公開するヘッダとして作成したとしても、
モジュール外からのインクルードを C 言語として禁止するものではありません。
あくまでも紳士協定です。

ですから、モジュール外部からインクルードされたときの事を考え、
モジュール内限定で公開するヘッダに書く情報も必要最低限になるようにするべきです。

   
*** 構造体型情報の公開

オブジェクト指向では、クラスのメンバにアクセスするには、
直接メンバにアクセスするのではなく、
メンバにアクセスするためのメソッド(アクセッサ)を介してアクセスします。

一方 C 言語の場合、メンバを含んだ構造体の定義を公開してしまうと、
そのメンバに対するアクセスを制限することは出来ません。

例えば、次の構造体の定義をヘッダファイルに含む場合、
そのヘッダファイルをインクルードしたところからは
制限なく TEST 構造体の value メンバにアクセス出来てしまいます。

#+BEGIN_SRC c
struct TEST {
  int value;
};
#+END_SRC

これを制限するには、次のようにメンバを含まない構造体定義をヘッダファイルにします。

==ー#+BEGIN_SRC c
struct TEST;
#+END_SRC

そして、実際に TEST 構造体を操作するモジュールのソース内で改めてメンバを含む定義をします。

#+BEGIN_SRC c
struct TEST {
  int value;
};
#+END_SRC

こうすることで、外部モジュールからは TEST 構造体のメンバにアクセスが出来なくなります。

ただしこの場合、外部モジュールでは TEST 構造体のポインタ型変数は作れますが、
TEST 構造体の変数を作れなくなります。
つまり、TEST構造体のインスタンスは固定領域かHEAPにつくることにな
注意が必要です。


#+BEGIN_SRC c
struct TEST test; // これは出来ない
struct TEST * pTest; // これは出来る
#+END_SRC

*** アクセッサ(get 系/set 系) の公開

これは C 言語に限った話ではなく一般的な話ですが、
アクセッサの公開は十分な注意が必要です。

まず大前提として、アクセッサは必要最低限のものだけを公開します。
そして、get 系はもちろんですが、set 系は get 系以上に公開する際に注意が必要です。

また、get 系でもポインタを取得するものであれば、
そのポインタに const がないと set 系を公開していることと同じことなので、
注意が必要です。

まとめると、アクセッサを公開する場合は、次の順に検討が必要です。

- ポインタ型でない get
- const ポインタの get
- set, const でないポインタの get

*** グローバル変数

グローバル変数はカプセル化の考え方から逸脱するため、
原則的には使うべきではありません。

しかし、RTOS の kernel 情報のように、
非常に高速性が求められるような場合で、
アクセッサを通すと規定のパフォーマンスを得られない時は
グローバル変数に直接アクセスすることも検討が必要です。
