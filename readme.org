# -*- coding:utf-8 -*-
#+STARTUP: nofold

* lctags

libclanglua (https://github.com/ifritJP/libclanglua) を利用した c/c++ インデックスツール

libclang を利用することで、異なる構造体、クラスで同名のメンバーがあるような場合でも、
型を認識して正確に参照箇所をリストできます。

libclang を利用したインデックスツールは RTags がメジャーですが、
複雑な Makefile を使用したプロジェクトだと適応し難いので、
プロジェクトごとにカスタマイズしやすいインタフェースを持った
インデックスツールを作成しました。

** 使用方法

lctags コマンドを使用します。
   
#+BEGIN_SRC txt
usage:
 - build DB
   lctags init projDir [-it] [-is] [-im]
   lctags build compiler  [--lctags-conf conf] [--lctags-target target] [--lctags-recSql file] comp-op [...] src
   lctags shrink [--lctags-db path]
   lctags chg-proj projDir [--lctags-db path]
   lctags update pattrn
 - query DB
   lctags dump
   lctags ref-at[a] [--lctags-target target] file line column 
   lctags def-at[a] [--lctags-target target] file line column 
   lctags call-at[a] [--lctags-target target] file line column
   lctags list <incSrc|inc> [-d depth] name
   lctags ns-at [--lctags-target target] file line column
   lctags -x[t|s|r][a]  [--use-global] symbol
   lctags -xP[a]  [--use-global] file
   lctags -c  [--use-global] symbol
 - graph
   lctags graph <incSrc|inc|caller|callee|symbol> [-d depth] [-b|-o file] [-f type] [name]
   lctags graph-at <caller|callee|symbol> [-d depth] [-b|-o file] [-f type] [--lctags-target target] file line column 

  option:
     init: initialize DB file. "projDir" is a root directory of your project.
       -it: enable individual type mode.
       -is: enable individual struct mode.
       -is: enable individual macro mode.
     build: build DB for "src".
            "compiler" is "gcc" or "cc" or ....
            "comp-op" is compiler option. This include source file path.
     shrink: shrink DB.
     chg-proj: change project directory.
     dump: dump DB.
     --lctags-conf: confing file.
     --lctags-target: set build target.
     -x: query DB.
        -xt: symbol declaration
        -xs: symbol declaration
        -xr: symbol reference
        -xP: file list
     -c: list symbol.
     def-at: symbol declaration at position
     ref-at: symbol reference at position
     call:at: function call at position
     --use-global: use GNU global when db is not found.
     graph: draw graph.
     graph-at: draw graph at position.
         inc: include relation.
         caller: caller graph.
         callee: callee graph.
         -d: depth.
         -b: browse graph.
         -o: output image file.
         -f: image type. (svg, png)

   common option:
     --lctags-quiet: discard clang diagnostic.
     --lctags-db: set DB file path.
     --lctags-log: set log level. default is 1. when lv > 1, it is datail mode.
#+END_SRC

*** DB の生成

$ lctags init .

プロジェクトのルートディレクトリで次のコマンドを実行します。
これは、一度だけ実行します。

*** ソースの解析

$ lctags build compiler [--lctags-target target] comp-op [...] src

ソースの解析を行ないます。コンパイルは行ないません。

compiler には、使用しているコンパイルコマンドを指定します。

comp-op には、コンパイラに指定しているコンパイルオプションを指定します。

src には、コンパイル対象のソースファイルパスを指定します。オプションの最後に指定する必要はありません。
src は、一つだけ指定してください。

このコマンドは、コンパイルを実行しているディレクトリと同じディレクトリで実行してください。

基本的には通常のコンパイルと同じオプションを渡すだけです。

例えば、 次のようにコンパイルしているソースを解析する場合、

$ gcc hoge.cpp -c -o hoge.o -Iinclude

次のように lctags を実行します。

$ lctags build gcc hoge.cpp -c -o hoge.o -Iinclude


なお、lctags はデフォルトで gcc のコンパイルオプションに対応していますが、
後述する方法で簡単にカスタマイズできます。

lctags は解析時に使用したコンパイルオプションを記憶し、
後述するインデックス問い合わせ時に利用します。
1 つのソースに対して、複数のコンパイルオプションを切り替えて
異なるオブジェクトを生成するような場合、
そのコンパイルオプションのセットを識別する必要があります。
--lctags-target オプションを指定することで、
コンパイルオプションを識別する名前を設定することができます。

*** インデックス問い合わせ

次のパターンを利用できます。
    
#+BEGIN_SRC txt
$ lctags -x[r|t][a] [--use-global] symbol
$ lctags ref-at[a] [--lctags-target target] file line column
$ lctags def-at[a] [--lctags-target target] file line column
#+END_SRC txt

-x は、 GNU global と互換のあるモードです。

r は、シンボルの参照場所をリストします。

t は、シンボルの定義場所をリストします。

a は、表示する場所のファイルパスをフルパスにします。
このモードでは、シンボル名だけを使用して問い合わせするので、
型を認識した検索には向きません。

--use-global を指定することで、
lctags の DB が存在しない場合に GNU global を実行します。


ref-at[a] は、指定ファイルの場所のシンボルを使用している参照箇所をリストします。

def-at[a] は、指定ファイルの場所のシンボルの定義箇所をリストします。

指定のファイルにコンパイルエラーがあると、正常に動作しません。

解析時に --lctags-target を指定している場合は、
--lctags-target を指定する必要があります。

*** emacs からアクセス

**** 設定
    
emacs からアクセスする場合は、 lctags.el をロードしてください。

#+BEGIN_SRC lisp
(add-to-list 'load-path "/hoge/foo/lctags" t)

(autoload 'lctags-mode "lctags" "" t)
(add-hook 'lctags-mode-hook
      '(lambda ()
         (local-set-key (kbd "M-t") 'lctags-def)
         (local-set-key (kbd "M-r") 'lctags-ref)
	 (local-set-key (kbd "C-c l") 'lctags-dispatch-mode)
	 (local-set-key (kbd "C-c C-/") 'lctags-helm-complete-at)
         (local-set-key (kbd "C-t") 'gtags-pop-stack)))

(add-hook 'c-mode-common-hook
          '(lambda()
	     (lctags-mode 1)))

;; (require 'lctags-anything)
(require 'lctags-helm)
#+END_SRC

なお、 lctags.el は gtags.el が利用できることが前提になっています。

**** 機能

lctags.el は、マイナーモードの機能を提供します。

以下の説明では、上記キーバイドが設定されていることを前提としています。

- lctags-def (M-t)
  - 指定シンボルの定義場所をリストします。
  - gtags-find-tag と互換の動作です。
  - C-u M-t とすることで、 lctags-def-at を実行します。
  - C-u C-u M-t とすることで、 lctags ではなく GNU global を利用します。
- lctags-ref (M-r)
  - 指定のシンボルの参照場所をリストします。
  - gtags-find-rtag と互換の動作です。
  - C-u M-r とすることで、 lctags-ref-at を実行します。
  - C-u C-u M-r とすることで、 lctags ではなく GNU global を利用します。
- lctags-def-at (C-c l d)
  - lctags コマンドの def-at オプションを呼び出します。
  - カーソル位置のシンボルの定義位置をリストします。
  - 対象ファイルを事前に lctags で解析しておく必要があります。
- lctags-ref-at (C-c l r)
  - lctags コマンドの ref-at オプションを呼び出します。
  - カーソル位置のシンボルの参照位置をリストします。
  - 対象ファイルを事前に lctags で解析しておく必要があります。
- lctags-call-at (C-c l c)
  - lctags コマンドの call-at オプションを呼び出します。
  - カーソル位置の関数の呼び出し位置をリストします。
  - 対象ファイルを事前に lctags で解析しておく必要があります。
- lctags-graph-caller-at (C-c l g r)
  - lctags コマンドの graph-at caller オプションを呼び出します。
  - カーソル位置の関数の呼び出し元を辿るコールグラフを表示します。
  - その対象ファイルを事前に lctags で解析しておく必要があります。
- lctags-graph-callee-at (C-c l g r)
  - lctags コマンドの graph-at callee オプションを呼び出します。
  - カーソル位置の関数の呼び出し先を辿るコールグラフを表示します。
  - その対象ファイルを事前に lctags で解析しておく必要があります。
- lctags-graph-symbol-at (C-c l g s)
  - lctags コマンドの graph-at symbol オプションを呼び出します。
  - カーソル位置のシンボルの参照元を辿るコールグラフを表示します。
  - その対象ファイルを事前に lctags で解析しておく必要があります。
- lctags-list-incSrc-this-file (C-c l l I)
  - 現在のバッファで開いているファイルをインクルードしているファイル一覧をリストします。
  - デフォルトは、4 階層までの結果をリストします。
  - C-c l l C-u N I で、解析する階層として N を指定できます。 N は数字キーです。
- lctags-list-inc-this-file (C-c l l i)
  - 現在のバッファで開いているファイルがインクルードしているファイル一覧をリストします。
  - デフォルトは、100 階層までの結果をリストします。
  - C-c l l C-u N I で、解析する階層として N を指定できます。 N は数字キーです。
- lctags-update-this-file (C-c l u)
  - 現在のバッファで開いているファイルを解析しなおします。
  - バッファで開いているファイルがヘッダファイルの場合は動作しません。

*** コード補完

シンボル名、メンバー名の補完を行ないます。

補完したい位置にカーソルを移動し、 C-c C-/ で候補を表示します。

補完候補の絞り込みは helm (あるいは anything) を利用します。

[[https://gist.githubusercontent.com/ifritJP/e9bd012e0f49f43db3ef230ee50c3fe6/raw/8557f03cd8d88d3329998db13b6567f37d706120/complete.gif]]

ファイルを変更している場合、補完が正常に動作しない場合があります。
一旦 lctags-update-this-file (C-c l u) で解析情報を更新してから実行してください。

*** グラフ

include、関数の関係を示すグラフを作成することができます。
この機能は graphviz の dot を利用します。
グラフは svg フォーマットで作成します。

**** サンプル

#+CAPTION: サンプル
[[./src/graph.sample/inc.png]]

**** オプション

#+BEGIN_SRC txt
$ lctags graph <incSrc|inc|caller|callee|symbol> [-d depth] [-b|-o file] [-f format] [name]
$ lctags graph-at <caller|callee|symbol> [-d depth] [-b|-o file] [-f type] [--lctags-target target] file line column 
#+END_SRC

次のグラフを作成します。

- include 元  (incSrc)
- include 先  (inc)
- 関数呼び出し元 (caller)
- 関数呼び出し先 (callee)
- シンボル参照元 (symbol)

name には、関数名あるいはファイル名あるいはシンボル名、
あるいはそれらを示す ID を指定します。
name を省略した場合、ID をリストします。
関数名、シンボル名は完全限定名で指定する必要があります。
ファイル名は、カレントディレクトリからの相対パスか、フルパスで指定します。

-d は、表示するグラフの階層を指定します。
デフォルトでは、4 階層までのグラフを作成します。

-o は、作成するグラフのファイル名を指定します。

-b は、作成したグラフを表示します。

-f は、作成するグラフの画像フォーマットを指定します。


*** プロジェクトディレクトリの変更

DB ファイルをプロジェクトのルートディレクトリとは別のディレクトリに作成している場合、
プロジェクトを別のディレクトリに移動したりコピーした際、
次のコマンドを実行する必要があります。

$ lctags chg-proj .

** ビルド方法

*** 必要なライブラリ等
+ swig (3.0)
+ lua, lua-dev(5.2 or 5.3)
+ libclang-dev (r380, r390)
+ luasqlite3 (0.9.4)
+ openssl

*** makefile の編集

lua, libclang, luasqlite3 の環境にあわせて変更してください。

*** ビルド

#+BEGIN_SRC txt
$ make build
$ make install
#+END_SRC

** カスタマイズ

lctags の次の動作をカスタマイズできます。

+ コンパイルオプションの変換
+ 解析無視のファイルパターン指定
  
カスタマイズは Lua で行ないます。

*** カスタマイズの方法

次のファイルをコピーし、これを編集します。

src/lctags/config.lua

編集したファイルのパスを、lctags build 時の --lctags-conf conf オプションに指定します。

**** コンパイルオプションの変換

lctags の build に指定するコンパイラ名を gcc 以外の名前を指定してください。

コピーしたコンフィルファイルの convertCompileOption() メソッドを、
使用しているコンパイラにあわせて変更してください。

インクルードパスと define シンボルを、
clang が認識する -I, -D で与えるように変換してください。

-I, -D 以外のオプションは与えないようにしてください。

convertCompileOption() は、2 つの引数(compiler, arg)を持ちます。
compiler は、 build で指定したコンパイラ名です。
arg はコンパイラオプション文字列です。

convertCompileOption() は、コンパイルオプションの変換結果を返します。
変換結果は次のいずれかです。

- "opt"
- "src"
- "skip"
  
"opt" は、 arg が libclang に渡すべきオプションであること示します。
このとき、"opt" に続けて libclang に渡すオプションを返します。

"src" は、 arg が解析対象のソースファイルパスであること示します。
このとき、"src" に続けてソースファイルパス返します。

"skip" は、arg が無視すべきオプションであることを示します。

getDefaultOptionList() は、
libclang に追加で指定するコンパイルオプションのリストを返します。


**** 解析無視のファイルパターン指定

lctags の build で指定されたファイルの解析を無視するかどうかを判定する
ファイルパスのパターンを指定します。

パターンは、 2 つの文字列を要素に持つ table の配列を返します。

#+BEGIN_SRC Lua
{
      { "simple", "ignore.c" }, -- this is simple match. 
      { "lua", "^ignore.c$" }, -- this is lua pattern match.
}
#+END_SRC

1つ目の文字列は "simple" か "lua" です。
2つ目の文字列は無視するファイルパスのパターンを指定します。

"simple" は、パターン文字列がファイルパス文字列そのものであることを示します。
なお、パターンが部分一致すると無視します。

"lua" は、パターン文字列が Lua のパターン文字列であることを示します。
パターンに一致すると無視します。
     
